
\documentclass[runningheads]{llncs}

\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.

\usepackage{booktabs}
\usepackage{tabularx}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}

\usepackage{listings}

\lstset{
    numberbychapter=false,
    numbers=left,
    numberstyle=\small,
    frame=single,
    framexleftmargin=20pt,
    breaklines=true,
    breakatwhitespace=true,
    basicstyle=\small\ttfamily,
    xleftmargin=20pt,
}

\usepackage[colorlinks=true]{hyperref}
\hypersetup{
    linkcolor=,
    urlcolor=blue,
    citecolor=,
}
\renewcommand\UrlFont{\color{blue}\rmfamily}


\begin{document}

% --------------------------------------------------------------------------------- title
\title{N3X: Formal Evaluation Semantics}
% include in title \thanks{tbd.}

%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here

\author{
    Matthias Farnbauer-Schmidt\inst{1}\orcidID{0000-0001-6858-0257}
}

\authorrunning{M. Farnbauer-Schmidt}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.

\institute{Friedrich-Alexander Universit\"at Erlangen-N\"urnberg, \\
    Chair of Technical Information Systems \\
    \email{matthias.farnbauer-schmidt@fau.de}
}

\maketitle



% ------------------------------------------------------------------------------ abstract
\begin{abstract}
    tbd.
    
    \keywords{Notation3 \and N3X \and formal semantics}
\end{abstract}



% ---------------------------------------------------------------------------------- body
\section{Introduction}
\label{sec:intro}



% \begin{lstlisting}[
%   label={lst:n3-distance},
%   caption={Distance between two 2D points as N3 rule.},
%   float=t,
% ]
% { ?p1 :x ?x1; :y ?y1. ?p2 :x ?x2; :y ?y2.
%   ?p1 log:notEqualTo ?p2.
%   (?x1 ?x2) math:difference ?dx.
%   (?y1 ?y2) math:difference ?dy.
%   (?dx 2) math:exponentiation ?dx2.
%   (?dy 2) math:exponentiation ?dy2.
%   (?dx2 ?dy2) math:sum ?sum.
%   ?sum math:sqrt ?sqrt. }
% => { :result :value ?sqrt. }.
% \end{lstlisting}


% \begin{lstlisting}[
%   label={lst:n3x-distance},
%   caption={Distance between two 2D points as N3X rule.},
%   float=t,
% ]
% { ?p1 :x ?x1; :y ?y1. ?p2 :x ?x2; :y ?y2.
%   ?p1 log:notEqualTo ?p2.
%   ?x1 - ?x2 = ?dx. ?y1 - ?y2 = ?dy. }
% => { :result :value math:sqrt(?dx*?dx + ?dy*?dy). }.
% \end{lstlisting}


\section{Summary of Arndt et al.: Core Logic}
\label{sec:def}

In \cite{Arndt.2019} the authors give a formal definition of Notation3 (N3) in the form of \emph{core logic}.
Later the semantics of N3X are built upon the definitions given.

The aim of \cite{Arndt.2019} is to formalize the scope of variables in N3.
In order to do so the first-order logic \emph{core logic} is introduced to describe the semantics of N3.
Following, a summary of it is given.



\subsection{Syntax}
\label{sec:def-core-syntax}

The syntax of \emph{core logic} is shown in \autoref{tab:cl-syntax}.

\begin{table}
  \centering
  \caption{Syntax of \emph{core logic}.}
  \label{tab:cl-syntax}
  \begin{tabular}{llr}
    \toprule
    \texttt{t ::=}$\qquad$ &  & terms: \\
      & \texttt{v}            & variables \\
      & \texttt{c}            & constants \\
      & \texttt{e}            & expressions \\
      & \texttt{(k)}          & lists \\
      & \texttt{()}           & empty list \\[0.5cm]
    \texttt{k ::=} &          & list content: \\
      & \texttt{t}            & \\
      & \texttt{t k}          & \\[0.5cm]
    \texttt{e ::=} &          & expressions: \\
      & \texttt{<f>}          & formula expression \\
      & \texttt{<>}           & true \\
      & \texttt{false}        & false \\[0.5cm]
    \texttt{f ::=} &          & formulae: \\
      & \texttt{t t t}        & atomic formula \\
      & $\texttt{e } \rightarrow \texttt{ e}$ & implication \\
      & \texttt{f f}          & conjunction \\
      & $\forall$\texttt{v.f} & universal formula \\
      & $\exists$\texttt{v.f} & existential formula \\
    \bottomrule
  \end{tabular}
\end{table}



\subsection{Semantics}
\label{sec:def-core-sem}

Following, the symbols used in the model theoretical description of \emph{core logic}'s semantics.


\subsubsection{Sets}

\begin{itemize}
  \item $\mathcal{V}$ is the set of (existential and universal) variables.
  \item $\mathcal{C}$ is the set of constants.
  \item $\mathcal{L}$ is the language of \emph{core logic} defined over $\mathcal{V}$ and $\mathcal{C}$, i.e. $\mathcal{L}$ over $\mathcal{V} \cup \mathcal{C}$.
  \item $\mathcal{T}$ is the set of terms.
\end{itemize}

\noindent\emph{Note:} In \emph{core logic} constants are not expressed in IRIs like in N3.
For example:

\begin{equation}
  \exists\texttt{x. x says <x knows Albert>}
\end{equation}


\subsubsection{Free variables and \emph{ground}}

\begin{itemize}
  \item The function $\texttt{FV}(l)$ returns the set of free variables in $l \in \mathcal{L}$.
  \item $l \in \mathcal{L}$ is called \emph{ground} iff $\texttt{FV}(l) = \emptyset$.
  \item $\mathcal{L}_g = \left\{l \mid \texttt{FV}(l) = \emptyset\right\}$ is the set of ground language elements.
  \item The set of ground terms is defined as $\mathcal{T}_g := \mathcal{L}_g \cap \mathcal{T}$.
\end{itemize}


\subsubsection{Connecting model and domain}

\begin{itemize}
  \item $\mathfrak{A} = (\mathcal{D}, \mathcal{P}, \mathfrak{a}, \mathfrak{p})$ is a structure over $\mathcal{L}$.
  \item $\mathcal{D}$ is the non-empty set of the domain of discourse.
  \item $\mathcal{P} \subset \mathcal{D}$ is the non-empty set of properties.
  \item $\mathfrak{a}: \mathcal{T}_g \rightarrow \mathcal{D}$ is the object mapping from model to domain of discourse.
  \item $\mathfrak{p}: \mathcal{P} \rightarrow 2^{\mathcal{D} \times \mathcal{D}}$ is the predicate mapping. It expresses the relation between elements of the domain of discourse $\mathcal{D}$.
\end{itemize}


\subsubsection{Grounding function}

\begin{itemize}
  \item $\gamma_g: \mathcal{V} \rightarrow \mathcal{T}_g$ is the grounding function mapping \emph{variables} to ground terms.
  \item $\gamma: \mathcal{L} \rightarrow \mathcal{L}_g$ is the extended grounding function that maps language elements to ground language elements.
  \item $\gamma\left[x \mapsto t\right]$ is $\gamma$ specifying that it is mapping variable $x$ to the term $t$, i.e. $\gamma(x) = t$ when $x \in \mathcal{V}$.
\end{itemize}


\subsubsection{Interpretation}

\begin{itemize}
  \item $\mathfrak{I} = (\mathfrak{A}, \gamma)$ is an interpretation of structure $\mathfrak{A}$ with the grounding function $\gamma$ over the language $\mathcal{L}$.
  \item We read $\mathfrak{I} \vDash x$ as the interpretation $\mathfrak{I}$ satisfies $x$.
  \item A formula \texttt{f} is true in $\mathfrak{I}$ when $\mathfrak{I} \vDash \texttt{f}$.
\end{itemize}

\noindent The following entailment rules apply:

\begin{enumerate}
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $(\mathfrak{a}(\gamma(\texttt{t}_1)), \mathfrak{a}(\gamma(\texttt{t}_3))) \in \mathfrak{p}(\mathfrak{a}(\gamma(\texttt{t}_2)))$.
  \item $\mathfrak{I} \vDash \texttt{<f}_1\texttt{>} \rightarrow \texttt{<f}_2\texttt{>}$ iff $\mathfrak{I} \vDash \texttt{f}_2$ if $\mathfrak{I} \vDash \texttt{f}_1$.
  \item $\mathfrak{I} \vDash \texttt{false} \rightarrow \texttt{<f>}$.
  \item $\mathfrak{I} \vDash \texttt{<f>} \rightarrow \texttt{<>}$.
  \item $\mathfrak{I} \vDash \texttt{<f>} \rightarrow \texttt{false}$ iff $\mathfrak{I} \nvDash \texttt{f}$.
  \item $\mathfrak{I} \vDash \texttt{<>} \rightarrow \texttt{<f>}$ iff $\mathfrak{I} \vDash \texttt{f}$.
  \item $\mathfrak{I} \vDash \texttt{f}_1 \texttt{f}_2$ iff $\mathfrak{I} \vDash \texttt{f}_1$ and $\mathfrak{I} \vDash \texttt{f}_2$.
  \item $\mathfrak{I} \vDash \forall\texttt{v.f}$ iff $(\mathfrak{A}, \gamma\left[\texttt{v} \mapsto \texttt{t}\right]) \vDash \texttt{f}$ for all $\texttt{t} \in \mathcal{T}_g$.
  \item $\mathfrak{I} \vDash \exists\texttt{v.f}$ iff $(\mathfrak{A}, \gamma\left[\texttt{v} \mapsto \texttt{t}\right]) \vDash \texttt{f}$ for some $\texttt{t} \in \mathcal{T}_g$.
\end{enumerate}

\noindent\emph{Note:} These rules only handle the implication.
However, N3 provides further logical predicates like \emph{log:includes} or \emph{log:semantics} which have their own semantics.



\subsection{Relation to N3}

The syntax of N3 can directly be mapped to \emph{core logic}.
We evaluate N3 by translating formulae to \emph{core logic} and interpret them.



\section{Functional Predicates in N3}
\label{sec:func}

The first-order logic \emph{core logic} lays the foundations of formal semantics for N3.
However, it only covers the most basic mechanism of interpreting formulae.
An important feature not included in \emph{core logic} but in N3 are functional predicates.
Instead of searching for a valid variable mappings, functional predicates allow to calculate new mappings.

In this section \emph{core logic} is extended to handle such functional (or sometimes called magic) predicates.



\subsection{Syntax}
\label{sec:func-syntax}

As functional predicates are built-in predicates, they do not have a dedicated syntax.



\subsection{Semantics}
\label{sec:func-semantic}

\begin{itemize}
  \item $\mathcal{P}_f = \left\{ p_f \mid p_f: \mathcal{T}_g^2 \rightarrow \left\{true, false\right\} \right\}$ is the set of filter functions which take two ground terms and return if the filter applies or not ($\mathcal{P}_f \subset \mathcal{P}$).
  \item $\mathcal{P}_c = \left\{ p_c \mid p_c: \mathcal{T}_g \rightarrow \mathcal{T}_g \right\}$ is the set of functions that calculate a new ground term by processing a given ground term ($\mathcal{P}_c \subset \mathcal{P}$).
\end{itemize}

\noindent Accordingly, there are additional entailment rules.
The new rules add to the rules, especially rule 1, of \emph{core logic} and do not replace them nor are they mutually exclusive.

\begin{enumerate}
  \setcounter{enumi}{9}
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $\mathfrak{a}(\gamma(\texttt{t}_2)) = p$ and $p \in \mathcal{P}_f$ and $p(\gamma(\texttt{t}_1), \gamma(\texttt{t}_3) ) = true$.
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $\mathfrak{a}(\gamma(\texttt{t}_2)) = p$ and $p \in \mathcal{P}_c$ and $\texttt{t}_3 \in \mathcal{T}_g$ and $p(\gamma(\texttt{t}_1)) = \texttt{t}_3$.
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $\mathfrak{a}(\gamma(\texttt{t}_2)) = p$ and $p \in \mathcal{P}_c$ and $\texttt{t}_3 \in \mathcal{V}$ and $\gamma\left[\texttt{t}_3 \mapsto p(\gamma(\texttt{t}_1))\right]$.
\end{enumerate}

\noindent These rules have been tested and acknowledged for the N3-engine \texttt{cwm}.



\section{N3X}
\label{sec:n3x}



\subsection{Syntax}
\label{sec:n3x-syntax}

For N3X the syntax of \emph{core logic} is expanded as shown in \autoref{tab:cl-syntax-n3x}.

\begin{table}
  \centering
  \caption{Extended syntax of \emph{core logic} for N3X.}
  \label{tab:cl-syntax-n3x}
  \begin{tabular}{llr}
    \toprule
    \texttt{t ::=}$\qquad$ &  & terms: \\
      & \texttt{v}            & variables \\
      & \texttt{c}            & constants \\
      & \texttt{e}            & expressions \\
      & \texttt{x}            & function calls \\
      & \texttt{(k)}          & lists \\
      & \texttt{()}           & empty list \\[0.5cm]
    \texttt{k ::=} &          & list content: \\
      & \texttt{t}            & \\
      & \texttt{t k}          & \\[0.5cm]
    \texttt{x ::=} &          & function calls: \\
      & \texttt{c()}          & no arguments \\
      & \texttt{c(a)}         & with arguments \\[0.5cm]
    \texttt{a ::=} &          & arguments: \\
      & \texttt{t}            & \\
      & \texttt{t, a}         & \\[0.5cm]
    \texttt{e ::=} &          & expressions: \\
      & \texttt{<f>}          & formula expression \\
      & \texttt{<>}           & true \\
      & \texttt{false}        & false \\[0.5cm]
    \texttt{f ::=} &          & formulae: \\
      & \texttt{t t t}        & atomic formula \\
      & $\texttt{e } \rightarrow \texttt{ e}$ & implication \\
      & \texttt{f f}          & conjunction \\
      & $\forall$\texttt{v.f} & universal formula \\
      & $\exists$\texttt{v.f} & existential formula \\
    \bottomrule
  \end{tabular}
\end{table}

In \emph{core logic} each N3X expression is represented as a function call.
The same applies to N3X's syntax for N3.
However, N3X borrows the syntactic sugar from SPARQL expressions to shorten certain common operations like addition or comparators.



\subsection{Semantics}
\label{sec:n3x-semantics}

N3X basically only introduces explicit function calls to \emph{core logic}.

\begin{itemize}
  \item $\mathcal{X} \subset \mathcal{T}$ is the set of function calls.
  \item Ground terms do not include function calls: $\mathcal{T}_g := \left\{\texttt{t} \mid \texttt{FV}(\texttt{t}) = \emptyset\right\} \setminus \mathcal{X}$.
  \item $\mathcal{F} \subset \mathcal{D}$ is the set of functions $f$ valid for function calls in N3X.
  \item We define $\mathcal{F} = \left\{f \mid f: \mathcal{T}_g^n \rightarrow \mathcal{T}_g\right\}$ as the set of functions that take $n$ ground terms and map them to a single ground term where $n \in \mathbb{N}_0$.
  \item Accordingly, $\mathcal{P}_f \subset \mathcal{F}$ and $\mathcal{P}_c \subset \mathcal{F}$ as $true$ and $false$ are members of $\mathcal{T}_g$.
  \item The function of free variables is extended:
    \begin{equation*}
      \texttt{FV}(\texttt{x}) = \texttt{FV}(\texttt{c}(\texttt{t}_1,\;\dots,\; \texttt{t}_n)) = \texttt{FV}(\texttt{t}_1) \cup \;\dots\; \cup \texttt{FV}(\texttt{t}_n)
    \end{equation*}
  \item The grounding function for function calls is defined as:
    \begin{equation*}
      \gamma(\texttt{x}) = \gamma(\texttt{c}(\texttt{t}_1,\;\dots,\; \texttt{t}_n)) = \texttt{c}(\gamma(\texttt{t}_1),\;\dots,\; \gamma(\texttt{t}_n))
    \end{equation*}
\end{itemize}



\subsubsection{Evaluation}
\label{sec:n3x-semantics-eval}

Let $\epsilon: \mathcal{T} \rightarrow \mathcal{T} \setminus \mathcal{X}$ be the evaluation function of terms.
The function is defined as follows:

\begin{align*}
  \epsilon(\texttt{v}) =\; & \texttt{v} \\
  \epsilon(\texttt{c}) =\; & \texttt{c} \\
  \epsilon(\texttt{<f>}) =\; & \texttt{<} \epsilon(\texttt{f}) \texttt{>} \\
  \epsilon(\texttt{<>}) =\; & \texttt{<>} \\
  \epsilon(\texttt{false}) =\; & \texttt{false} \\
  \epsilon(\texttt{(t}_1 \;\dots\; \texttt{t}_n \texttt{)} ) =\; & \texttt{(}\epsilon(\texttt{t}_1) \;\dots\; \epsilon(\texttt{t}_n) \texttt{)} \\
  \epsilon(\texttt{()}) =\; & \texttt{()} \\
  \epsilon(\texttt{t}_1\texttt{t}_2\texttt{t}_3) =\; & \epsilon(\texttt{t}_1) \epsilon(\texttt{t}_2) \epsilon(\texttt{t}_3) \\
  \epsilon(\texttt{e}_1 \rightarrow \texttt{e}_2) =\; & \epsilon(\texttt{e}_1) \rightarrow \epsilon(\texttt{e}_2) \\
  \epsilon(\texttt{f}_1 \texttt{f}_2) =\; & \epsilon(\texttt{f}_1) \epsilon(\texttt{f}_2) \\
  \epsilon(\forall\texttt{v.f}) =\; & \forall\texttt{v.}\epsilon(\texttt{f}) \\
  \epsilon(\exists\texttt{v.f}) =\; & \exists\texttt{v.}\epsilon(\texttt{f}) \\
  \epsilon(\texttt{x}) =\; & \mathfrak{a}(\texttt{c})(\epsilon(\texttt{t}_1), \;\dots,\; \epsilon(\texttt{t}_n)) \\
\end{align*}

\noindent This means that $\epsilon$ is recursively applied and only take effect on function calls \texttt{x}.
For evaluation of \texttt{x}, first the function is retrieved by resolving the constant \texttt{c} where $\mathfrak{a}(\texttt{c}) \in \mathcal{F}$.
Then the evaluation of arguments is passed to the function.
The result of the evaluation is the result of the referred function with the given arguments.

The evaluation of variables returns them unchanged.
Therefore, arguments must first be grounded as functions of $\mathcal{F}$ only take ground terms.
As a result, we denote $\epsilon_g(l) = \epsilon(\gamma(l))$ as the grounded evaluation of language element $l \in \mathcal{L}$.



\subsubsection{Interpretation}
\label{sec:n3x-semantics-interpret}

With the extension of \emph{core logic} and the grounded evaluation $\epsilon_g$ the interpretation rules change as follows:

\begin{enumerate}
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $(\mathfrak{a}(\epsilon_g(\texttt{t}_1)), \mathfrak{a}(\epsilon_g(\texttt{t}_3))) \in \mathfrak{p}(\mathfrak{a}(\epsilon_g(\texttt{t}_2)))$.
  \item $\mathfrak{I} \vDash \texttt{<f}_1\texttt{>} \rightarrow \texttt{<f}_2\texttt{>}$ iff $\mathfrak{I} \vDash \texttt{f}_2$ if $\mathfrak{I} \vDash \texttt{f}_1$.
  \item $\mathfrak{I} \vDash \texttt{false} \rightarrow \texttt{<f>}$.
  \item $\mathfrak{I} \vDash \texttt{<f>} \rightarrow \texttt{<>}$.
  \item $\mathfrak{I} \vDash \texttt{<f>} \rightarrow \texttt{false}$ iff $\mathfrak{I} \nvDash \texttt{f}$.
  \item $\mathfrak{I} \vDash \texttt{<>} \rightarrow \texttt{<f>}$ iff $\mathfrak{I} \vDash \texttt{f}$.
  \item $\mathfrak{I} \vDash \texttt{f}_1 \texttt{f}_2$ iff $\mathfrak{I} \vDash \texttt{f}_1$ and $\mathfrak{I} \vDash \texttt{f}_2$.
  \item $\mathfrak{I} \vDash \forall\texttt{v.f}$ iff $(\mathfrak{A}, \gamma\left[\texttt{v} \mapsto \texttt{t}\right]) \vDash \texttt{f}$ for all $\texttt{t} \in \mathcal{T}_g$.
  \item $\mathfrak{I} \vDash \exists\texttt{v.f}$ iff $(\mathfrak{A}, \gamma\left[\texttt{v} \mapsto \texttt{t}\right]) \vDash \texttt{f}$ for some $\texttt{t} \in \mathcal{T}_g$.
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $\mathfrak{a}(\epsilon_g(\texttt{t}_2)) = p$ and $p \in \mathcal{P}_f$ and $p(\epsilon_g(\texttt{t}_1), \epsilon_g(\texttt{t}_3) ) = true$.
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $\mathfrak{a}(\epsilon_g(\texttt{t}_2)) = p$ and $p \in \mathcal{P}_c$ and $\texttt{t}_3 \in \mathcal{T}_g$ and $p(\epsilon_g(\texttt{t}_1)) = \texttt{t}_3$.
  \item $\mathfrak{I} \vDash \texttt{t}_1 \texttt{t}_2 \texttt{t}_3$ iff $\mathfrak{a}(\epsilon_g(\texttt{t}_2)) = p$ and $p \in \mathcal{P}_c$ and $\texttt{t}_3 \in \mathcal{V}$ and $\gamma\left[\texttt{t}_3 \mapsto p(\epsilon_g(\texttt{t}_1))\right]$.
\end{enumerate}

\noindent All in all, the evaluation is only applied when atomic formulae are interpreted (rules 1, 10, 11 and 12).



\section{Conclusion}
\label{sec:concl}

First a summary of \emph{core logic} defined in \cite{Arndt.2019} was given.
We added formal semantics for the execution of functional predicates.

Based on this foundational work we introduced the the semantics for N3X.
Which means an extension of \emph{core logic} (and N3) by explicit function calls that can be used like every other term.
We presented a syntax for such function calls.

The semantics of the extended \emph{core logic} only adds an evaluation function $\epsilon$ and extends existing free-variables and grounding function to handle function calls.
The evaluation merely means the call of a function with the given arguments.
It is only applied when atomic formulae are interpret.

All in all, the changes are small.
The extension of an existing N3-engine by N3X is the next task we will conduct.


% -------------------------------------------------------------------------- bibliography

\bibliographystyle{splncs04}
\bibliography{source.bib}

\end{document}
